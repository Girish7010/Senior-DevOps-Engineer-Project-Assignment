name: Deploy (build, push, apply)

on:
  push:
    branches: [ "main" ]

env:
  REGISTRY: ghcr.io
  IMAGE_BACKEND: ghcr.io/${{ github.repository_owner }}/metrics-backend
  IMAGE_FRONTEND: ghcr.io/${{ github.repository_owner }}/metrics-frontend
  TAG: ${{ github.sha }}

jobs:
  deploy:
    # ----- OPTION A: self-hosted runner on your minikube machine -----
    # runs-on: self-hosted
    # labels: [ linux, x64 ]   # if you set labels

    # ----- OPTION B: GitHub-hosted runner + KUBECONFIG_B64 secret -----
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      # Login to GHCR
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}   # works for GHCR in most orgs; else use REGISTRY_PASSWORD

      # Build & push backend
      - name: Build backend image
        run: docker build -t $IMAGE_BACKEND:$TAG -f backend/Dockerfile backend
      - name: Push backend
        run: docker push $IMAGE_BACKEND:$TAG

      # Build & push frontend
      - name: Build frontend image
        run: docker build -t $IMAGE_FRONTEND:$TAG -f frontend/Dockerfile frontend
      - name: Push frontend
        run: docker push $IMAGE_FRONTEND:$TAG

      # ----- KUBECONFIG handling -----
      # OPTION A (self-hosted): skip; your runner already has ~/.kube/config pointing to minikube

      # OPTION B (GitHub-hosted): write kubeconfig from secret
      - name: Configure KUBECONFIG from secret
        if: ${{ env.RUNNER_ENV != 'self-hosted' && secrets.KUBECONFIG_B64 != '' }}
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_B64 }}" | base64 -d > $HOME/.kube/config

      # Install kubectl
      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.33.4

      # Apply manifests
      - name: Apply Kubernetes manifests
        run: |
          kubectl apply -f k8s/namespace.yaml
          kubectl -n monitoring-dashboard apply -f k8s/frontend-nginx-configmap.yaml
          kubectl -n monitoring-dashboard apply -f k8s/backend-svc.yaml
          kubectl -n monitoring-dashboard apply -f k8s/frontend-svc.yaml
          kubectl -n monitoring-dashboard apply -f k8s/backend-deploy.yaml
          kubectl -n monitoring-dashboard apply -f k8s/frontend-deploy.yaml

      # Update images to the new tag
      - name: Set images to new tag
        run: |
          kubectl -n monitoring-dashboard set image deploy/backend  backend=$IMAGE_BACKEND:$TAG
          kubectl -n monitoring-dashboard set image deploy/frontend frontend=$IMAGE_FRONTEND:$TAG

      # Wait for rollouts
      - name: Wait for rollout
        run: |
          kubectl -n monitoring-dashboard rollout status deploy/backend
          kubectl -n monitoring-dashboard rollout status deploy/frontend

      # Final check
      - name: Show services
        run: kubectl -n monitoring-dashboard get pods,svc,endpoints
